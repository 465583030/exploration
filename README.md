Exploration - (探索软件开发的方法论) A Exploration for the Methodology of Software Development  

内容提要
=======
* [前言](#前言)
* [DDD介绍](#DDD介绍)
    * [基本概念](#基本概念)
    * [分层架构](#分层架构)
* [DDD工程实践](#DDD工程实践)
    * [需求](#需求)
    * [战略建模](#战略建模)
    * [战术建模](#战术建模)
    * [架构设计](#架构设计)
* [总结](#总结)    
* [参考文献](#参考文献)
 
前言
===

至少30年以前，一些软件设计人员就已经意识到领域建模和设计的重要性，并形成一种思潮，Eric Evans将其定义为**领域驱动设计**（**Domain-Driven Design**，简称**DDD**）。

在互联网开发“小步快跑，迭代试错”的大环境下，**DDD**似乎是一种比较“古老而缓慢”的思想。

然而，由于互联网公司也逐渐深入实体经济，业务日益复杂，我们在开发中也越来越多地遇到传统行业软件开发中所面临的问题。

本项目以互联网中的一个真实需求为例，讲解如何利用**DDD**的思想设计和开发互联网业务需求。

因为只是讲解**DDD**的方法论，并不是讲解代码和业务，所以代码实现上只是设计了类及方法，没有实现里面具体的业务逻辑。

DDD介绍
======

基本概念
------
- **领域**(Domain)

我们所做的软件系统的目的都是来解决一系列问题，例如做一个电商系统来在线销售自己企业的产品；做一个灰度发布平台来提升服务的质量和稳定性。

任何一个系统都会属于某个特定的领域，例如：论坛是一个领域：要做一个论坛，那这个论坛的核心业务是确定的，比如用户发帖、回帖等核心基本功能；电商系统是一个领域：只要是电商领域的系统，那核心业务就是：商品浏览、购物车、下单、减库存、付款交易等核心环节。

同一个领域的系统都具有相同的核心业务，因为他们要解决的问题的本质是类似的。

一个领域本质上可以理解为一个问题域及解系统。只要确定了系统所属的领域，那么这个系统的核心业务，即要解决的关键问题就基本确定了。

通常我们说，要成为一个领域的专家，必须要在这个领域深入研究很多年才行，只有这样才会遇到非常多的该领域的问题，积累了丰富的经验。

- **限界上线文**(Bounded Context)

通常来说，一个领域有且只有一个核心问题，我们称之为该领域的『核心子域』。在核心子域、通用子域、支撑子域梳理的同时，会定义出子域中的『限界上下文』及其关系，用它来阐述子域之间的关系 。界限上下文可以简单理解成一个子系统或组件模块。

- **领域模型**(Domain Model)

领域驱动设计（Domain-Driven Design）分为两个阶段：

1） 以一种领域专家、设计人员、开发人员都能理解的**通用语言**作为相互交流的工具，在交流的过程中发现领域概念，然后将这些概念设计成一个**领域模型**；

2）由领域模型驱动软件设计，用代码来实现该领域模型；

由此可见，领域驱动设计的核心是建立正确的领域模型。领域模型具有以下特点：

1）对具有某个边界的领域的一个抽象，反映了领域内用户 业务需求的本质 。它属于『解决问题空间』。领域模型是有边界的，只反应了我们在领域内所关注的部分，包括 实体概念（如：货物，书本，应聘记录，地址等），以及 过程概念（如：资金转账等）；

2）**提高软件的可维护性，业务可理解性以及可重用性**。领域模型确保了我们的软件的业务逻辑都在一个模型中，帮助开发人员相对平滑地将领域知识转化为软件构造；

3）贯穿软件 分析、设计、开发 的整个过程。领域专家、设计人员、开发人员面向同一个模型进行交流，彼此共享知识与信息，所以可以防止需求走样，让软件开发人员做出来的软件真正满足需求；要建立正确的领域模型并不简单，需要领域专家、设计、开发人员积极沟通共同努力，然后才能使大家对领域的认识不断深入，从而不断细化和完善领域模型；

4）为了让领域模型看的见，使用的常用表达领域模型的方式：图、代码或文字；

5）重要性：领域模型是整个软件的核心，是软件中最有价值和最具竞争力的部分；**设计足够精良且符合业务需求的领域模型能够更快速的响应需求变化**。

- **通用语言**(Ubiquitous Language)

由软件专家和领域专家合作开发一个领域的模型是有必要的。开发过程中， 开发人员以类、算法、设计模式、架构等进行思考与交流。但领域专家对此一无所知，他们对技术上的术语没有太多概念，只了解特有的领域专业技能，例如：在空中交通监控样例中，领域专家知道飞机、路线、海拔、经度、纬度，他们有自己的术语来讨论这些事情。软件专家和领域专家交流过程中，需要做翻译才能让对方理解这些概念。

领域驱动设计的一个核心原则是使用一种基于模型的语言。使用模型作为语言的核心骨架，要求团队在进行所有的交流是都使用一致的语言，在代码中也是这样，这种语言被称为『通用语言』。

- **领域服务**(Domain Service)

领域中的一些概念不太适合建模为对象（实体对象或值对象），因为它们本质上就是一些操作、动作，而不是事物。这些操作往往需要 协调多个领域对象。如果强行将这些操作职责分配给任何一个对象，则被分配的对象就是承担一些不该承担的职责，从而会导致对象的职责不明确很混乱。DDD认为领域服务模式是一个很自然的范式用来对应这种跨多个对象的操作。一般的领域对象都是有状态和行为的，而领域服务没有状态只有行为。

领域服务还有一个很重要的功能就是可以避免领域逻辑泄露到应用层。因为如果没有领域服务，那么应用层会直接调用领域对象完成本该是属于领域服务该做的操作，需要了解每个领域对象的业务功能，以及它可能会与哪些其他领域对象交互等一系列领域知识。这样一来，领域层可能会把一部分领域知识泄露到应用层。对于应用层来说，通过调用领域服务提供的简单易懂且意义明确的接口肯定也要比直接操纵领域对象容易的多。

- **实体**(Entity)

实体就是领域中需要 唯一标识 的领域概念。因为我们有时需要区分是哪个实体：有两个实体，如果唯一标识不一样，那么即便实体的其他所有属性都一样，也认为他们是两个不同的实体。

不应该给实体定义太多的属性或行为，而应该寻找关联，将属性或行为转移到其他关联的实体或值对象上。比如：Customer 实体，有一些地址信息，由于地址信息是一个完整的有业务含义的概念，所以我们可以定义一个 Address 对象，然后把 Customer 的地址相关的信息转移到 Address 对象上。如果没有 Address 对象，而把这些地址信息直接放在 Customer 对象上，然后对于一些其他的类似Address的信息也都直接放在Customer 上，会导致 Customer 对象很混乱，结构不清晰，最终导致它难以维护和理解。

- **值对象**(Value Object)

并不是每一个事物都必须有一个唯一标识。就以上面的地址对象 Address 为例，如果两个 Customer 的地址信息是一样的，我们就会认为这两个 Customer 的地址是同一个。用程序的方式来表达就是：如果两个对象所有属性的值都相同，我们会认为它们是同一个对象，那么就可以把这种对象设计为值对象。

值对象的特征：

1）值对象 没有唯一标识 ，这是它和实体的最大不同。值对象在判断是否是同一个对象时是通过它们的所有属性是否相同，如果相同则认为是同一个值对象。在区分是否是同一个实体时，只看实体的唯一标识是否相同，而不管实体的属性是否相同。

2）值对象是 不可变 的，即所有属性都是只读的，所以可以被安全的共享。

- **聚合**(Aggregate)/**聚合根**(Aggregate Root)

聚合定义了一组具有 内聚关系 的相关对象的集合，以及对象之间清晰的所属关系和边界，避免了错综复杂的难以维护的对象关系网的形成。我们把聚合看作是一个修改数据的单元。

聚合有以下特点：

1）每个聚合有一个根和一个边界：根是聚合内的某个实体；边界定义了一个聚合内部有哪些实体或值对象；

2）聚合根是外部可以保持对聚合引用的唯一元素，负责与外部其他对象打交道并维护自己内部的业务规则。聚合内部的对象之间可以相互引用，但是聚合外部如果要访问聚合内部的对象时，必须通过聚合根开始导航，绝对不能绕过聚合根直接访问聚合内的对象；

3）聚合内除根以外的其他实体的唯一标识都是本地标识，也就是只要在聚合内部保持唯一即可，因为它们总是从属于这个聚合的；

4）聚合内部的对象可以保持对其他聚合根的引用；

5）删除一个聚合根时必须同时删除该聚合内的所有相关对象，因为他们都同属于一个聚合，是一个完整的概念；

基于聚合的以上概念，我们可以推论出从数据库查询时的单元也是以聚合为一个单元，不能直接查询聚合内部的某个非根的对象；

- **工厂**(Factory)

DDD中的工厂也是一种体现 封装思想 的模式。DDD中引入工厂模式的原因是：有时创建一个领域对象是一件比较复杂的事情，不仅仅是简单的new操作。工厂是用来封装创建一个复杂对象尤其是聚合时所需的知识，将创建对象的细节（如何实例化对象，然后做哪些初始化操作）隐藏起来。

- **资源库**(Repository)

仓储被设计出来的原因：领域模型中的对象自从创建后不会一直留在内存活动，当它不活动时会被持久化到DB中，当需要的时候会重建该对象。所以，重建对象是一个和DB打交道的过程，需要提供一种机制，提供类似集合的接口来帮助我们 管理对象。

分层架构
-------
![ddd-layer](assets/ddd-layer.png)

用户界面/展示层：1）请求应用层获取用户所需的展示数据；2）发送命令给应用层执行用户的命令。

应用层：薄薄的一层，定义软件要完成的任务。对外为展示层提供各种应用功能，对内调用领域层（领域对象或领域服务）完成各种业务逻辑。应用层不包含业务逻辑。

领域层：表达业务概念、业务状态信息及业务规则，是业务软件的核心。

基础设施层：为其他层提供通用的技术能力，提供了层间通信；为领域层提供持久化机制。

DDD工程实践
=========

需求
---

在互联网应用中，总想引导或者激励用户去重复体验自己的产品。通常，我们会在后台设置很多小的任务，当用户使用产品并完成这些任务，会给用户对应的奖励。

例如，在很火的游戏“王者荣耀”中，当游戏玩家在某特定时段完成了指定场数的游戏，系统会赠送游戏玩家金币和铭文碎片。

本项目把具体的业务场景简化，抽象成一个任务系统，用**领域驱动设计DDD**的方法来设计和开发这个任务系统。

具体需求如下：

1）运营人员会在后台根据不同用户设置不同的任务。

2）每个任务都有不同的完成条件（例如，连续登陆N天），可以是一次性完成，也可以是分多次才能够完成。

3）每个任务设置不同的奖励，当用户完成这个任务的时候，就能够获得该奖励。奖励可以自动发送到用户账号，也可以用户自己领取。

4）用户可以查看当前有哪些活动和活动对应的奖励，完成某个活动的进度，领奖奖励。

针对上述需求，本项目尝试用DDD的思想来分析、建模、设计并最终编码该任务系统。

战略建模
----

[TODO]

战术建模
----

[TODO]

架构设计
------

[TODO]

总结
===

[TODO]

参考文献
=======

[1] [领域驱动设计在互联网业务开发中的实践](https://zhuanlan.zhihu.com/p/32459776)

[2] [领域驱动设计的基础知识总结](https://www.cnblogs.com/butterfly100/p/7827870.html)



